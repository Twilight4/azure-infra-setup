* Table of Contents :toc:
- [[#3-layer-cloud-infrastructure-on-azure][3-layer cloud infrastructure on Azure]]
  - [[#repository-layout][Repository layout]]
  - [[#project-overview][Project overview]]
- [[#steps-to-deploy][Steps to deploy]]
  - [[#prerequisites][Prerequisites]]
  - [[#authenticate-with-azure][Authenticate with Azure]]
  - [[#create-terraform-state-backend][Create Terraform State Backend]]
  - [[#deploy-the-infrastructure][Deploy the infrastructure]]
  - [[#verify-deployment][Verify deployment]]
  - [[#clean-up][Clean up]]
- [[#roadmap-wip][Roadmap WIP]]

* 3-layer cloud infrastructure on Azure
This repo demonstrates a secure, scalable three-layer (web/app/db) Azure architecture using Terraform modules. It follows hub-and-spoke network pattern, central security services (Azure Firewall + NSGs), managed DBs with private network access, and scaleable compute.

** Repository layout
#+begin_src shell
azure-three-layer-terraform/
├── README.md
├── environments/
│ ├── dev.tfvars
│ └── prod.tfvars
├── global/
│ ├── backend.tf # example remote state using azurerm storage account
│ └── providers.tf
├── modules/
│ ├── network/
│ │ ├── main.tf # hub-and-spoke / vnet + subnets + peering + route tables + NAT
│ │ ├── variables.tf
│ │ └── outputs.tf
│ ├── security/
│ │ ├── main.tf # Azure Firewall, NSGs, Route Tables, Key Vault policies
│ │ ├── variables.tf
│ │ └── outputs.tf
│ ├── compute/
│ │ ├── main.tf # VM scale set or AKS plus application gateway / load balancer
│ │ ├── variables.tf
│ │ └── outputs.tf
│ └── db/
│ ├── main.tf # Azure Database for PostgreSQL / MySQL / or managed SQL
│ ├── variables.tf
│ └── outputs.tf
├── staging/ # example environment that composes modules
│ ├── main.tf
│ ├── variables.tf
│ └── outputs.tf
└── versions.tf
#+end_src

** Project overview
*** Repo
- Modular layout with these modules:
  + *network* — hub-and-spoke VNet(s), peering, NAT/route table hooks
  + *security* — Azure Firewall, NSGs, route tables, basic Key Vault wiring
  + *compute* — VM Scale Set example (can be swapped for AKS) and hooks for autoscale
  + *db* — managed DB (MySQL shown) with private access and firewall rule example
- Root environment example (staging) that composes the modules.
- Remote-state backend example using *azurerm* storage account.

*** Architecture overview (three-layer, Azure-focused)
- *Presentation (web) layer* in its own spoke VNet/subnet, fronted by Application Gateway (WAF) or public LB.
- *Application (app) layer* in a separate spoke — hosts app server VMSS or AKS.
- *Data (db) layer* in its own spoke containing managed DB services (Azure Database for PostgreSQL / MySQL / SQL) with =public_network_access_enabled = false= so only private connectivity is allowed.
- *Shared Hub VNet* contains central services: Azure Firewall, VPN/ExpressRoute gateways, NAT, and peering to spokes. This follows Azure =hub-and-spoke= best practices. 

*** Key security and operational choices
1. *Hub-and-spoke networking* — centralizes security, simplifies routing and egress, isolates workloads.
2. *Azure Firewall + NSGs* — firewall for east-west and perimeter rules; NSGs for subnet-level micro-segmentation. Use firewall for inspection and NSGs for fast path filtering. Azure docs/tech guidance confirm this pattern. 
3. *Managed DB with private access* — keep DBs off public internet and restrict access from app subnets only. (The example module configures firewall rules and disables public access.)
4. *Remote state + locking* — store Terraform state in an Azure Storage Account container with blob locking or use Terraform Cloud. Avoid local state for teams.
5. *Modules & standard structure* — keep reusable modules (network, security, compute, db) to make environments (dev/staging/prod) easy to manage and test.


* Steps to deploy
** Prerequisites
- Azure subscription (Owner or Contributor role)
- Azure CLI installed (az)
- Terraform installed (terraform)
- Git

** Authenticate with Azure
Service principal is safer for CI/CD, but interactive login is fine for learning.

**** Option A — Interactive login (simplest)
#+begin_src shell
# Your Azure CLI will use your logged-in account for Terraform.
az login
#+end_src

**** Option B — Service Principal (recommended for automation)
#+begin_src shell
# Create a service principal (replace <subscription-id>)
az ad sp create-for-rbac --name "tf-sp-learning" --role Contributor --scopes /subscriptions/<subscription-id>

# Verify the created service principal
az ad sp list --display-name tf-sp-learning -o table

# To see more details for tf-sp-learning (The secret can't be viewed again)
az ad sp list --display-name tf-sp-learning -o json | jq

# Note the output
{
  "appId": "...",
  "password": "...",
  "tenant": "..."
}

# Set environment variables for Terraform
# If you use interactive login, these are not strictly needed, but required if using SP
export ARM_CLIENT_ID="<appId>"
export ARM_CLIENT_SECRET="<password>"
export ARM_TENANT_ID="<tenant>"

# To list subscription ids
az account list -o table

# To check subscription-id
az account show --query id -o tsv

# Export subscription ID
export ARM_SUBSCRIPTION_ID="<subscription-id>"

# Log in to service principal
az logout
az login --service-principal \
  -u <appId> -p <password> --tenant <tenantId>
#+end_src

** Create Terraform State Backend
Terraform needs a remote backend to store its state.

#+begin_src shell
# Create a resource group
az group create -n rg-tfstate -l <REGION>

# Create a storage account (account name must be globally unique)
az storage account create \
  --name tfstatestorage<UNIQUE> \
  --resource-group rg-tfstate \
  --location westeurope \
  --sku Standard_LRS \
  --subscription <subscription-id>

# To List all resource groups located in the west europe region
az group list --query "[?location=='westeurope']"

# Get storage account key
KEY=$(az storage account keys list -g rg-tfstate -n tfstatestorage<UNIQUE> --query "[0].value" -o tsv)
# Create a blob container for terraform state
az storage container create --name tfstate --account-name tfstatestorage<UNIQUE> --account-key $KEY
#+end_src

Then update =global/backend.tf= to point at this container.
#+begin_src tf
resource_group_name  = "rg-tfstate"                        # Resource group where the storage account lives
storage_account_name = "tfstatestorage<UNIQUE>"            # Storage account name (must be globally unique)
container_name       = "tfstate"                           # Container inside the storage account used to store the state blob
key                  = "dev.terraform.tfstate"             # Key path for the specific state file (use different keys per environment)
#+end_src

** Deploy the infrastructure
#+begin_src shell
# Go to the environment folder:
cd environments/dev

# Initialize Terraform (If you changed backend settings, you need to run terraform init -reconfigure)
terraform init -reconfigure

# Preview changes
terraform plan -var-file=../../environments/dev.tfvars

# Apply changes - this will create all resources: VNets, subnets, firewall, VM Scale Set, database, etc
terraform apply -var-file=../../environments/dev.tfvars
#+end_src

** Verify deployment
**** Using Azure Portal
- Go to [[https://portal.azure.com/][portal.azure.com]]
- Navigate to =Resource Groups= → select your environment group (e.g., =rg-dev=)
- Verify the resources exist

**** Using Azure CLI
#+begin_src shell
# check the resource group and resources
az group list -o table

# List virtual networks in the RG
az network vnet list -g rg-dev -o table

# Show firewall public IP
az network public-ip show -g rg-staging -n stg-fw-pip --query "{ip: ipAddress}" -o tsv

# Show storage account for the resource group
az storage account list -g rg-tfstate -o table
#+end_src

** Clean up
#+begin_src shell
# Remove all terraform resources and avoid charges
terraform destroy -var-file=../../environments/dev.tfvars

# Remove service principal named tf-sp-learning
az ad sp delete --id tf-sp-learning

# Remove a blob container for terraform state named tfstatestorage4123
az storage container delete \
  --name tfstatestorage<UNIQUE> \
  --account-name tfstatestorage<UNIQUE>

# Remove storage account for that rg-tfstate resource group named tfstatestorage<UNIQUE>
az storage account delete \
  --name tfstatestorage<UNIQUE> \
  --resource-group rg-tfstate \
  --yes

# Remove a resource group named rg-tfstate
az group delete \
  --name rg-tfstate \
  --yes --no-wait
#+end_src

* Roadmap WIP
- [ ] Use Azure Key Vault to provide secrets (DB password, etc.) and do not store secrets in git or =.tfvars= checked into source.
- [ ] Add CI pipeline
- [ ] =modules/appgw/= for Application Gateway + WAF module
- [ ] =modules/aks/= if using containers (AKS + managed identities)
- [ ] =modules/monitoring/= for Log Analytics workspace, diagnostic settings, alerts
- [ ] Put compute behind Azure Load Balancer (internal) or Application Gateway (WAF+TLS termination). Use VMSS or AKS to scale application layer.
- [ ] Use Availability Zones where available for Firewall PIP and compute resources like VMSS/DB (or zone-redundant SKUs). See Azure Firewall deploy docs for zone examples. 
- [ ] Monitor and autoscale using Azure Monitor autoscale rules and alerts.
